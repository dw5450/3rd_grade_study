//컨테이너의 요소 접근
//벡터의 값에 access해 보자
#include <iostream>
using namespace std;
int gid = 0;

class Model {
private:
	static int gid;
	int id;
	char* data = nullptr;
	size_t size = 0;
public:
	Model() :id(++gid) { cout << id << " - 디폴트 생성자" << endl; }
	explicit Model(size_t s) :size(s), id(++gid) {
		data = new char[size];
		cout << id << " - 생성자	크기 : " << size << "	주소 : " << static_cast<void*>(data) << endl;
	}
	Model(const Model& m) :id(++gid) {
		size = m.size;
		data = new char[size];
		// 깊은 복사
		memcpy(data, m.data, size);

		cout << id << " - 복사 생성자	크기 : " << size << "		주소 : " << static_cast<void*>(data) << endl;
	}
	~Model() {
		cout << id << " - 소멸자	크기 : " << size << "		주소 : " << static_cast<void*>(data) << endl;
		if (data != nullptr)
			delete[] data;
	}
	Model& operator=(const Model& m) {	// 복사할당자
		if (this == &m)
			return *this;

		size = m.size;
		if (data != nullptr) {
			delete[] data;
		}
		data = new char[size];
		memcpy(data, m.data, size);

		cout << id << " - 복사할당자	크기 : " << size << "		주소 : " << static_cast<void*>(data) << endl;
		return *this;
	}
	// 이동 생성자, 이동 할당 연산자
	Model(Model&& other) :id(++gid) {
		size = other.size;
		data = other.data;
		// 원본은 well-known 상태로 만들어주자(defaul값)
		other.size = 0;
		other.data = 0;

		cout << id << " - 이동생성자	크기 : " << size << "		주소 : " << static_cast<void*>(data) << endl;
	}
	Model& operator=(Model&& other) {
		if (this == &other)
			return *this;

		size = other.size;
		if (data != nullptr) {
			delete[] data;
		}
		data = other.data;

		// 원본은 well-known 상태로 만들어주자(defaul값)
		other.size = 0;
		other.data = 0;

		cout << id << " - 이동할당 연산자		크기 : " << size << "		주소 : " << static_cast<void*>(data) << endl;
		return *this;
	}
	friend ostream& operator<<(ostream&, const Model&);

	int getSize()const { return size; }
};
int Model::gid = 0;
ostream& operator<<(ostream& os, const Model& m) {
	os << "아이디 : " << m.id << endl;
	os << "크기 : " << m.size << endl;
	os << "데이터 : " << static_cast<void*>(m.data) << endl;
	return os;
}

// array : 유일하게 컴파일시에 크기가 결정되어야 하는 컨테이너
// 기존 배열의 문제점: 배열의 이름이 메모리 시작번지이고 
// 어디든 이름을 사용하여 access가능 (경계를 벗어나도 대책이 없다.)
// 이를 방지하기 위해 array를 사용하여 프로그램을 돌림

///////////배열 클레스를 가져오기 위한 헤더///////////////
#include<array>
//vector :  dynamic array 실행시 크기가 변한다.
//vector.size(); 담고 있는 원소의 갯수
//vector.capacity(); 원소를 몇 개 담을 수 있는지를 나타내는 수, 용량
//vector.data(); Free store에 확보한 메모리의 시작번지
//벡터를 사용하기 위한 벡터 헤더 삽입
#include <vector>

int main() {

	/////////////////////////////////벡터의 메모리 연산////////////////////////////////////////////
	//vector<int> v;

	/////////////////////////////벡터의 공간을 미리 설정해보자 ///////////////////////////
	//v.reserve(500);								//500를 넣을 수 있도록 공간을 예약



	///////백터가 자신의 범위를 넘어가는 푸시 백을 할때 어떻게 변하는지 확인해 보자/////
	////v.push_back(i) 하면서 capacity가 바뀔때 마다 아래 세 줄 출력
	//int prevCapacity = v.capacity();
	//for (int i = 0; i < 1000; ++i)
	//{
	//	v.push_back(i);
	//	if (v.capacity() != prevCapacity) {
	//		cout << " -----------------------------------------" << endl;
	//		cout << "원소의 갯수 : " << v.size() << endl;
	//		cout << "담을 수 있는 갯수 : " << v.capacity() << endl;
	//		cout << "확보한 메모리번지 : " << v.data() << endl;
	//		cout << " -----------------------------------------" << endl;
	//	}
	//	prevCapacity = v.capacity();
	//}

	/////////////////자신의 담을수 있었던 데이터량 /2 만큼 가능한량이 증가함//////////////////	

	////data()를 이용해서 v[0]의 값을 100으로 변경

	///**(v.data()) = 100;

	//cout << v[0] << endl;*/
	////쓰일일이 거의 없다.

	///////////////////////////////////////////////////////////////////////////////////////////////////////////


//	////////////////////////벡터의 여러가지 반복문 부르는 방법////////////////////////////////
//
//	vector<int> v{ 1, 2, 3, 4, 5 ,6, 7, 8, 9, 10 };
//
//
//	//////////이터레이터 설정을 통한 반복///////////
//	/*vector<int>::iterator i = v.begin();
//	vector<int>::iterator end = v.end();
//
//	for (i; i != end; ++i)
//		*i = (*i) * 2;
//*/
//	//for (auto i = v.begin(); i != v.end(); ++i)
//	//	*i = (*i) * 2;
//
//	/////////v.size를 이용한 반복////////////////////
//	/*for (int i = 0; i < v.size(); ++i)
//		v[i] = v[i] * 2;
//
//	for (int i = 0; i < v.size(); ++i)
//		cout << v[i] << endl;
//*/
//	//////////////범위 지정 반복문//////////////////////
//
//	////여기에 오토를 쓰는건 합당하지 않음. 데이터를 명시적으로 나타낼수 없기 때문//
//	for (int & data : v)
//		data = data * 2;
//	
//	for (const int & data : v)
//		cout << data << endl;
//	
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////벡터에 값을 넣는 방법 //////////////////////////////////////////////

	vector<Model> v;
	v.reserve(10);

	/////////선언된 값을 직접 넣는 경우////////////

	cout << "---------------------------- 변수 --------------------------" << endl;
	Model a{ 1 };
	v.push_back(a);
	/////////무브로 넣는 경우 , 임시 객체로 넣는 경우 

	cout << "---------------------------- 임시 객체 --------------------------" << endl;
	v.push_back(Model(22));

	/////////그냥 값으로 넣는 경우 -> 막아야함 -> 생성자에 explicit(명시적으로) 선언//////////////
	//v.push_back(22);

	cout << "---------------------------- 바로 생성 --------------------------" << endl;
	/////////바로 생성해 버리는 경우 /////////////
	v.emplace_back(33 );

	cout << "------------------------- 프로그램 종료 ---------------------------" << endl;

}