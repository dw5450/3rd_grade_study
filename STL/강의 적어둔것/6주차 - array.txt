////////////////////////////////////////////////////////////////
//4장 순차 컨테이너 (sequence container)
//
//array, vector, deque, list, forward_list
////////////////////////////////////////////////////////////////



#include<iostream>
using namespace std;

//컨테이너의 요소 접근
//벡터의 값에 access해 보자
#include <iostream>
class Model {
private:
	static int gid;
	int id;
	char* data = nullptr;
	size_t size = 0;
public:
	Model() :id(++gid) { cout << id << " - default ctor" << endl; }
	Model(size_t s) :size(s), id(++gid) {
		data = new char[size];
		cout << id << " - 생성자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
	}
	Model(const Model& m) :id(++gid) {
		size = m.size;
		data = new char[size];
		// 깊은 복사
		memcpy(data, m.data, size);

		cout << "복사 생성자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
	}
	~Model() {
		cout << id << " - 소멸자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
		if (data != nullptr)
			delete[] data;
	}
	Model& operator=(const Model& m) {	// 복사할당자
		if (this == &m)
			return *this;

		size = m.size;
		if (data != nullptr) {
			delete[] data;
		}
		data = new char[size];
		memcpy(data, m.data, size);

		cout << id << " - 복사할당자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
		return *this;
	}
	// 이동 생성자, 이동 할당 연산자
	Model(Model&& other) :id(++gid) {
		size = other.size;
		data = other.data;
		// 원본은 well-known 상태로 만들어주자(defaul값)
		other.size = 0;
		other.data = 0;

		cout << "이동생성자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
	}
	Model& operator=(Model&& other) {
		if (this == &other)
			return *this;

		size = other.size;
		if (data != nullptr) {
			delete[] data;
		}
		data = other.data;

		// 원본은 well-known 상태로 만들어주자(defaul값)
		other.size = 0;
		other.data = 0;

		cout << id << " - 이동할당 연산자 - " << size << ", 바이트: " << static_cast<void*>(data) << endl;
		return *this;
	}
	friend ostream& operator<<(ostream&, const Model&);

	int getSize()const { return size; }
};
int Model::gid = 0;
ostream& operator<<(ostream& os, const Model& m) {
	os << "모델: " << m.id << endl;
	os << "크기: " << m.size << endl;
	os << "데이터: " << static_cast<void*>(m.data) << endl;
	return os;
}

// array : 유일하게 컴파일시에 크기가 결정되어야 하는 컨테이너
// 기존 배열의 문제점: 배열의 이름이 메모리 시작번지이고 
// 어디든 이름을 사용하여 access가능 (경계를 벗어나도 대책이 없다.)
// 이를 방지하기 위해 array를 사용하여 프로그램을 돌림

///////////배열 클레스를 가져오기 위한 헤더///////////////
#include<array>

int main() {

	array<int, 5>num_arr{ 1, 2, 3, 4, 5 };

	//기본은 무조건 빠른코드 오류 체크는 다른 언어에서? ///////////
	cout << "num_arr[-1] :  " << num_arr[-1] << endl;
	//기본적으로 오류를 '무시'하고 진행함 -> 이상한 값이 나올수 있음

	while (true) {
		cout << "몇번째 값을 출력할까여 ? ";
		int n;
		cin >> n;

	////////////////////try check를 통한 오류 체크를 할경우////////////////////
		try {
		//num_arr.at(n) // at을 써서 접근을 해야 오류를 체크할 수 있다 
			cout << "원하시는 값입니다" << num_arr.at(n) << endl;
		
		}
		catch (exception & e)
		{
			cout << "잘못된 값입니다." << endl;
			break;
		}
	/////////////////////////////////if 문을 통한 오류 체크////////////////////////////////////////
		/*if (0 <= n && n < num_arr.size())
			cout << "원하시는 값입니다" << num_arr.at(n) << endl;*/

		
	}

	////////////////////////배열 길이가 다르면 다른 자료형////////////////////////////////////
	array<int, 5> x;
	array<int, 6> y;

	///////////////////////// 모델을 배열 선언 해보자///////////////////////////////////////
	array<Model, 5> a{ 1, 22, 333, 4444, 5 };

	for (Model &d : a)
		cout << d;
	cout << "------------------------------실행이 종료 되었습니다 ---------------------------------------" << endl;
}