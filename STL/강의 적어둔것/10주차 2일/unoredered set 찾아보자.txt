/////////////////////////////////////////////////////////////////////////////////////////////
//2018.04.16		STL (월 23 , 화 56)					 7주 1
//
// 5장. 연관 컨테이너												정렬하는 이유, 빨리 찾기 위해서, 정렬의 기준이 되는 것이 키
//		정렬의 기준은 <(less 연산자)
//	set				- 키 값에 따라 정렬								기본 오름 차순을 한다/ 처음 값을 넣기는 힘들지만 찾기는 좋다. 겹치지 않아!
//	map				- 키와 밸류로 구성, 키가 정렬의 기준			가수 이름 : 노래 등
//	unordered_set	- 키값을 해싱하여 저장
//	unordered_map	- 키와 밸류로 구성 , 키값을 해싱하여 밸류를 저장할 곳을 지정
////내일 여기에서 시작합니다. Model 클레스를  mapㅇ에 넣어보자
///////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <unordered_set>
//다음 헤더는 실행시 지워야 할것입니다
#include "Model.h"							//모델을 사용할시 추가후 사용해 주세요
#include "save.h"
#include "funcSpeedCheck.h"
using namespace std;

//시험에 안나옴

class MyHash {
	public:
		size_t operator()(const Model & a) const {
			hash<int> hashVal;
			
			return hashVal(a.getSize());

		}

};
int main()
{
	unordered_set<Model, MyHash> us;
	us.emplace(1);
	us.emplace(22);
	us.emplace(333);

	//while (true) {
	//	int num;
	//	cout << "추가할 정수를 입력하세요 (-1 입력하면 끝내기) ";
	//	cin >> num;


	//	if (num == -1)
	//		break;
	//	us.emplace(num);

	//	//메모리를 출력한다

	//	/*for (int i = 0; i < us.bucket_count(); ++i) {
	//		cout << "[" << i << " ] - ";
	//		for (auto p = us.begin(i); p != us.end(i); ++p)
	//			cout << *p << ' ';
	//		cout << endl;
	//	}
	//	cout << endl;*/
	//	cout << "-------------------------------------------------------------" << endl;

	//}
	save("unoredered set 찾아보자.txt");

}
