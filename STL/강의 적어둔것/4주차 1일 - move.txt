
/////////////////////////////////////////////////////////////////////////
//2018 년 3월 26일 STL
// 책 2장 - Utility functions
//
//벡터에서 Model 클레스 관찰
//
//	- 벡터는 동적 배열이다.
//	- 벡터는 관리하는 객체의 갯수만큼 메모리를 동적으로 할당한다
//	- 벡터가 관리하는 객체가 깊은 복사를 한다면 관찰하기에 어려울만큼
//	  많은 메세지가 출력된다
//- 벡터는 새로운 객체가 추가 될 대 필요에 따라 메모리를 새로 확보하고 
//	새 객체를 제일 마지막 번지에 복사하고, 이전 객체를 모두 새 메모리에 복사한다
//	그런데, 새 메모리의 복사되는 객체는 프로그래머와는 아무 관계 없이 벡터
//	내부에서만 사용되는 객체들이다. 따라서 깊은 복사를 하지 않을 수만 있다면
//	벡터는 더 효율적으로 동작할 것이다
//
//c++11 에서는 이와같은 경우 class가 이동을 지원한다면 벡터사대신
//이동을 지원한다.
//
//***
//	당신이 소멸자, 복사 생성자, 복사 할당자, (이동 생성자, 이동 할당자) 중 
// 한개라도 프로그램했다면 나머지도 반드시 프로그램 해야만한다.
// 자원을 할당했기 때문에
//
//
//////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>
#include <chrono>
#include <string>
#include "save.h"
using namespace std;

int gid = 0;

class Model
{
	int id;
	char * data = nullptr;				//동적 할당한 메모리의 시작번지
	size_t size = 0;					//메모리의 크기



public:
	Model() : id(++gid) {
		cout << id << " - default ctor" << endl;		//생성자 관찰
	}

	Model(int n) : size(n), id(++gid) {
		data = new char[n];
		cout << id << "생성자 - " << size << "바이트, 주소 : " << static_cast<void *>(data) << endl;		//생성자 관찰
	}

	Model(const Model & other) : id(++gid) {
		size = other.size;

		data = new char[size];

		memcpy(data, other.data, size);	//deep copy
		cout << id << "복사 생성자, size_t : " << this->size << endl;		//생성자 관찰
	}

	size_t getSize_t() const { return size; }
	char * getData() const { return data; }

	Model & operator=(const Model & other)
	{
		if (this == &other)
			return *this;

		size = other.size;
		if (data != nullptr)
			delete[] data;

		data = new char[size];

		memcpy(data, other.data, size);	//deep copy
		cout << "복사 할당자, size_t : " << this->size << endl;		//생성자 관찰

		return *this;
	}

	//이동 생성자 / 이동 할당 연산자
	Model(Model && other) : id(++gid) {
		size = other.size;
		data = other.data;
		//원본은 well-known 상태로 만들어주자 (default 값)
		other.size = 0;
		other.data = nullptr;
		cout << id << "이동 생성자, size_t : " << this->size << endl;		//생성자 관찰


	}
	Model & operator=(Model && other) {
		if (this == &other)
			return *this;

		size = other.size;
		if (data != nullptr)
			delete[] data;

		this->size = other.size;
		this->data = other.data;
		other.size = 0;
		other.data = nullptr;
		cout << "이동 할당자, size_t : " << this->size << endl;		//생성자 관찰

		return *this;


	}
	
	
	~Model()
	{
		cout << id << "소멸자 - " << size << "바이트, 주소 :" << static_cast<void *>(data) << endl;		//생성자 관찰
		if(data != nullptr)
			delete [] data;
	}
};

int main()
{
	
	vector<Model> v;// 스택에 생기는 메모리


	Model a{ 7000 };


	v.push_back(a);


	save();

	cout << "__________메인문 종료 ____________" << endl;


	//#include <thread>
	//auto begin = chrono::high_resolution_clock::now();

	//chrono::high_resolution_clock::now();

	//this_thread::sleep_for(300ms);	//14/11이상에서만 돌아감

	//auto elapsedTime = chrono::high_resolution_clock::now() - begin;
	//cout << chrono::duration<double>(elapsedTime).count() << "초" << endl;

	//백터가 더 나중에 소멸된다?
	
};